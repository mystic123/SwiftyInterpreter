//anonymous functions has to return something
//example: insertion sort with given comparator
func sort(A: &Array of int, n:int, comp: func (int, int) -> bool) {
	var i = 1
	while (i < n) {
		var k = A[i]
		var j = i - 1
		while (j >= 0 && comp(A[j],k)) {
			A[j + 1] = A[j]
			A[j] = k
			j = j - 1
		}
		i = i + 1
	}
}
var N = 10
var arr = {1, 5, 7, 2, 6, 9, 0, 2, 7, 1}

print arr

//sorting in decreasing order
sort(arr, N, (a:int, b:int) -> bool in { return a < b })
print arr

sorting in growing order
var comp = (a:int, b:int) -> bool in { return a > b }
sort(arr, N, comp)
print arr

//recursive lambda
var fibo = (n:int) -> int in {
	if (n == 0)
		return 0
	if (n == 1)
		return 1
	return fibo(n-2) + fibo(n-1)
}

print fibo(10)

//assigning lambda function to variable
var f = fibo
print f(10)

//passing by reference
var addOne = (n:&int) -> int in {
	n = n + 1
	return 0
}

var x = 0
addOne(x)
print x

var c = 100
var l = () -> int in {
	//wiazanie zmiennych
	return c
}

print l()

//funkcja zwracajaca funkcje
var l1 = () -> (func (int) -> int) in {
	return ((x:int) -> int in { return x + 500 })
}

var l2 = l1()
print l2(8)

