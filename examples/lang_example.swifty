//zwykla funkcja
func fiboIter(n:int) -> int {
	var a,b = (0,1)
	while (n > 1) {
		var tmp = a
		a = b
		b = tmp + b
		n = n - 1
	}
	return b
}

//rekurencja, zagniezdzone funkcje
func fiboRec(n:int) -> int {
	func minusOne(x:int) -> int {
		return x - 1
	}
	func minusTwo(x:int) -> int {
		return minusOne(minusOne(x))
	}
	if (n == 0) 
		return 0
	if (n == 1) 
		return 1
	return fiboRec(minusOne(n)) + fiboRec(minusTwo(n))
}

//procedura, dynamiczne wiazanie
func printt() {
	//te zmienne sa jeszcze niezadeklarowane w tym miejscu
	print fi
	print fr
}

func printX() {
	print x
}

//przekazywanie przez referencje
func fiboMemo(n:int, memory:&Array of int) -> int {
	memory[0] = 0
	memory[1] = 1
	func fiboWithMemo(n:int) -> int {
		if (n == 0) {
			return 0
		}
		else if (n == 1) {
				return 1
		} else {
			if (memory[n] == -1) {
				var f = fiboWithMemo(n-1) + fiboWithMemo(n-2)
				memory[n] = f
			}
		}
		return memory[n]
	}
	if (memory[n] == -1) {
		return fiboWithMemo(n)
	} else {
		return memory[n]
	}
}

//zmienne
var a = 10
a = 20
var b = true
b = false
//redeklaracja zmiennej w tym samym bloku - zmienna a typu int przestaje byc dostepna
var a = false

var n = 10
var fi = fiboIter(n)
var fr = fiboRec(n)

printt()

//tablice
//array(n, x) tworzy tablice o rozmiarze n z powtorzona wartoscia x
var fiboNumbers = array(11,-1)

//lista inicjalizacyjna
var arr = {1,2,3}
//dzialania na tablicach
arr = arr + 5 // {6,7,8}
arr = arr - 3 // {3,4,5}
arr = arr * 10 // {30,40,50}
arr = arr / 2 // {15,20,25}
print arr 

//funkcja zwracajaca tablice
func rectArray(n:int, m:int) -> Array of Array of int {
	//tworzy tablice o wymiarach n x m wypelniona zerami
	return array(n, array(m, 0))
}
var arr2 = rectArray(10,10)
//modyfikacja komorek tablicy
arr2[0][0] = 10
arr2[5][5] = 50
arr2[9][9] = 90

//foreach
for x in arr2 {
	//tablica jest przekazywana przez referencje, tzn ta linijka ja modyfikuje nie tylko lokalnie
	x[1] = 1
	print x
}

//przekazywanie tablicy do funkcji
var fm = fiboMemo(5,fiboNumbers)
print fiboNumbers
fm = fiboMemo(10,fiboNumbers)
print fiboNumbers

//bloki
var x = 10
{
	printX() // 10
	x = 20
	printX() // 20
	//przesloniecie x (lokalna w bloku zmienna)
	var x = false
	printX() // false
	{
		printX() // false
		x = true
	}
	printX() // true
}
printX() // 20

//krotki
var tup = (111,222,false)
print tup

//przypisanie z krotki
var q,w,e = tup 
q,w,e = (222,333,true)
print q
print w
print e

//przekazywanie krotki i zwracanie krotki
func reverseTuple(t:(int,int,bool)) -> (bool,int,int) {
	var a,b,c = t
	return (c,b,a)
}

var tup2 = reverseTuple(tup)
print tup2

//structy
struct str
str.a = 10
str.b = false
//tablica w structcie
str.t = {777,888,999}
str.tup = (false,5,3)

struct str2
str2.x = 5
str2.y = 55
print str2
//zagniezdzanie structow
str.c = str2
print str

//modyfikacja structow
str.a = 20
str.t[0] = 444
str.c.x = 500

print str
print str.c

struct point
point.x = 0
point.y = 0
//tablica structow
var rect = array(4,point)
rect[0].x = 1
rect[0].y = 1
rect[1].x = 2
rect[1].y = 2
rect[2].x = 3
rect[2].y = 3
rect[3].x = 3
rect[3].y = 3

print rect

//w obecnej wersji gramatyka nie pozwala na przekazywanie structow jako parametrow funkcji ani na ich zwracanie
